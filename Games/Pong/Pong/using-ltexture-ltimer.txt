// Setup SDL
#include "SDL.h"
#include <iostream>

#include <SDL_image.h>
#include <SDL_ttf.h>

#include <string>
#include <sstream>

#include "Ball.h"
//#include "LTexture.h"

// Screen Dimentions Constants
const int gSCREEN_WIDTH = 800;
const int gSCREEN_HEIGHT = 400;

//Texture wrapper class
class LTexture
{
public:
   //Initializes variables
   LTexture();

   //Deallocates memory
   ~LTexture();

   //Loads image at specified path
   bool loadFromFile(std::string path);

#if defined(SDL_TTF_MAJOR_VERSION)
   //Creates image from font string
   bool loadFromRenderedText(std::string textureText, SDL_Color textColor);
#endif

   //Deallocates texture
   void free();

   //Set color modulation
   void setColor(Uint8 red, Uint8 green, Uint8 blue);

   //Set blending
   void setBlendMode(SDL_BlendMode blending);

   //Set alpha modulation
   void setAlpha(Uint8 alpha);

   //Renders texture at given point
   void render(int x, int y, SDL_Rect* clip = NULL, double angle = 0.0, SDL_Point* center = NULL, SDL_RendererFlip flip = SDL_FLIP_NONE);

   //Gets image dimensions
   int getWidth();
   int getHeight();

private:
   //The actual hardware texture
   SDL_Texture* mTexture;

   //Image dimensions
   int mWidth;
   int mHeight;
};


// The window we'll be rendering to
SDL_Window* gWindow = nullptr;
// The surface contained by the window
SDL_Surface* gScreenSurface = nullptr;

bool gQuit = false;

// From Mike Shah *_* https://www.youtube.com/watch?v=9P_MAgSNZx8&ab_channel=MikeShah
// Similar to what we have in OpenGL (Context), a Renderer is where we hold the state. It takes up the whole screen/window. 
SDL_Renderer* gRenderer = nullptr;

//Globally used font
TTF_Font* gFont = NULL;

//Scene textures
LTexture gTimeTextTexture;
LTexture gPromptTextTexture;

//Scene textures
LTexture gFPSTextTexture;

//The application time based timer
class LTimer
{
public:
   //Initializes variables
   LTimer();

   //The various clock actions
   void start();
   void stop();
   void pause();
   void unpause();

   //Gets the timer's time
   Uint32 getTicks();

   //Checks the status of the timer
   bool isStarted();
   bool isPaused();

private:
   //The clock time when the timer started
   Uint32 mStartTicks;

   //The ticks stored when the timer was paused
   Uint32 mPausedTicks;

   //The timer status
   bool mPaused;
   bool mStarted;
};

LTexture::LTexture()
{
   //Initialize
   mTexture = NULL;
   mWidth = 0;
   mHeight = 0;
}

LTexture::~LTexture()
{
   //Deallocate
   free();
}

bool LTexture::loadFromFile(std::string path)
{
   //Get rid of preexisting texture
   free();

   //The final texture
   SDL_Texture* newTexture = NULL;

   //Load image at specified path
   SDL_Surface* loadedSurface = IMG_Load(path.c_str());
   if (loadedSurface == NULL)
   {
      printf("Unable to load image %s! SDL_image Error: %s\n", path.c_str(), IMG_GetError());
   }
   else
   {
      //Color key image
      SDL_SetColorKey(loadedSurface, SDL_TRUE, SDL_MapRGB(loadedSurface->format, 0, 0xFF, 0xFF));

      //Create texture from surface pixels
      newTexture = SDL_CreateTextureFromSurface(gRenderer, loadedSurface);
      if (newTexture == NULL)
      {
         printf("Unable to create texture from %s! SDL Error: %s\n", path.c_str(), SDL_GetError());
      }
      else
      {
         //Get image dimensions
         mWidth = loadedSurface->w;
         mHeight = loadedSurface->h;
      }

      //Get rid of old loaded surface
      SDL_FreeSurface(loadedSurface);
   }

   //Return success
   mTexture = newTexture;
   return mTexture != NULL;
}

#if defined(SDL_TTF_MAJOR_VERSION)
bool LTexture::loadFromRenderedText(std::string textureText, SDL_Color textColor)
{
   //Get rid of preexisting texture
   free();

   //Render text surface
   SDL_Surface* textSurface = TTF_RenderText_Solid(gFont, textureText.c_str(), textColor);
   if (textSurface != NULL)
   {
      //Create texture from surface pixels
      mTexture = SDL_CreateTextureFromSurface(gRenderer, textSurface);
      if (mTexture == NULL)
      {
         printf("Unable to create texture from rendered text! SDL Error: %s\n", SDL_GetError());
      }
      else
      {
         //Get image dimensions
         mWidth = textSurface->w;
         mHeight = textSurface->h;
      }

      //Get rid of old surface
      SDL_FreeSurface(textSurface);
   }
   else
   {
      printf("Unable to render text surface! SDL_ttf Error: %s\n", TTF_GetError());
   }


   //Return success
   return mTexture != NULL;
}
#endif

void LTexture::free()
{
   //Free texture if it exists
   if (mTexture != NULL)
   {
      SDL_DestroyTexture(mTexture);
      mTexture = NULL;
      mWidth = 0;
      mHeight = 0;
   }
}

void LTexture::setColor(Uint8 red, Uint8 green, Uint8 blue)
{
   //Modulate texture rgb
   SDL_SetTextureColorMod(mTexture, red, green, blue);
}

void LTexture::setBlendMode(SDL_BlendMode blending)
{
   //Set blending function
   SDL_SetTextureBlendMode(mTexture, blending);
}

void LTexture::setAlpha(Uint8 alpha)
{
   //Modulate texture alpha
   SDL_SetTextureAlphaMod(mTexture, alpha);
}

void LTexture::render(int x, int y, SDL_Rect* clip, double angle, SDL_Point* center, SDL_RendererFlip flip)
{
   //Set rendering space and render to screen
   SDL_Rect renderQuad = { x, y, mWidth, mHeight };

   //Set clip rendering dimensions
   if (clip != NULL)
   {
      renderQuad.w = clip->w;
      renderQuad.h = clip->h;
   }

   //Render to screen
   SDL_RenderCopyEx(gRenderer, mTexture, clip, &renderQuad, angle, center, flip);
}

int LTexture::getWidth()
{
   return mWidth;
}

int LTexture::getHeight()
{
   return mHeight;
}








LTimer::LTimer()
{
   //Initialize the variables
   mStartTicks = 0;
   mPausedTicks = 0;

   mPaused = false;
   mStarted = false;
}

void LTimer::start()
{
   //Start the timer
   mStarted = true;

   //Unpause the timer
   mPaused = false;

   //Get the current clock time
   mStartTicks = SDL_GetTicks();
   mPausedTicks = 0;
}

void LTimer::stop()
{
   //Stop the timer
   mStarted = false;

   //Unpause the timer
   mPaused = false;

   //Clear tick variables
   mStartTicks = 0;
   mPausedTicks = 0;
}

void LTimer::pause()
{
   //If the timer is running and isn't already paused
   if (mStarted && !mPaused)
   {
      //Pause the timer
      mPaused = true;

      //Calculate the paused ticks
      mPausedTicks = SDL_GetTicks() - mStartTicks;
      mStartTicks = 0;
   }
}

void LTimer::unpause()
{
   //If the timer is running and paused
   if (mStarted && mPaused)
   {
      //Unpause the timer
      mPaused = false;

      //Reset the starting ticks
      mStartTicks = SDL_GetTicks() - mPausedTicks;

      //Reset the paused ticks
      mPausedTicks = 0;
   }
}

Uint32 LTimer::getTicks()
{
   //The actual timer time
   Uint32 time = 0;

   //If the timer is running
   if (mStarted)
   {
      //If the timer is paused
      if (mPaused)
      {
         //Return the number of ticks when the timer was paused
         time = mPausedTicks;
      }
      else
      {
         //Return the current time minus the start time
         time = SDL_GetTicks() - mStartTicks;
      }
   }

   return time;
}

bool LTimer::isStarted()
{
   //Timer is running and paused or unpaused
   return mStarted;
}

bool LTimer::isPaused()
{
   //Timer is running and paused
   return mPaused && mStarted;
}




void InitializeSDLWindow()
{
   // Initialize SDL
   if (SDL_Init(SDL_INIT_VIDEO) < 0)
   {
      std::cout << "SDL counld not be initialized! SDL Error: " << SDL_GetError();
   }
   else
   {
      // Create window
      gWindow = SDL_CreateWindow("Pong", SDL_WINDOWPOS_UNDEFINED, SDL_WINDOWPOS_UNDEFINED, gSCREEN_WIDTH, gSCREEN_HEIGHT, SDL_WINDOW_SHOWN);
      
      if (gWindow == NULL)
      {
         std::cout << "Window could not be created! SDL Error: " << SDL_GetError();
      }
      else
      {
         // Create renderer for window
         gRenderer = SDL_CreateRenderer(gWindow, -1, SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC); // create vsynced renderer for window
         if (gRenderer == NULL) 
         {
            std::cout << "Renderer could not be created! SDL Error: " << SDL_GetError();
            SDL_DestroyWindow(gWindow);
            SDL_Quit();
            return;
         }
         else
         {
            //Initialize PNG loading
            int imgFlags = IMG_INIT_PNG;
            if (!(IMG_Init(imgFlags) & imgFlags))
            {
               printf("SDL_image could not initialize! SDL_image Error: %s\n", IMG_GetError());
               //success = false;
            }

            //Initialize SDL_ttf
            if (TTF_Init() == -1)
            {
               printf("SDL_ttf could not initialize! SDL_ttf Error: %s\n", TTF_GetError());
               //success = false;
            }
         }

         // Set renderer color to white
         SDL_SetRenderDrawColor(gRenderer, 255, 255, 255, SDL_ALPHA_OPAQUE);

         // Get window surface
         gScreenSurface = SDL_GetWindowSurface(gWindow);

         // Fill the surface white
         SDL_FillRect(gScreenSurface, NULL, SDL_MapRGB(gScreenSurface->format, 0, 0, 0));

         // Update the surface
         SDL_UpdateWindowSurface(gWindow);
      }
   }
}

//void Input()
//{
//   // Check for quit event to close the window
//   SDL_Event e;
//
//   // Constantly pull and see if there are any events here
//   while (SDL_PollEvent(&e) != 0)
//   {
//      if (e.type == SDL_QUIT) {
//         gQuit = true;
//      }
//      // Reset start time on return keypress
//      else if (e.type == SDL_KEYDOWN && e.key.keysym.sym == SDLK_RETURN)
//      {
//         // SDL_GetTicks() returns the time since the program started in milliseconds.
//         startTime = SDL_GetTicks();
//      }
//   }
//}

bool loadMedia()
{
   //Loading success flag
   bool success = true;

   //Open the font
   gFont = TTF_OpenFont("./lazy.ttf", 28);
   if (gFont == NULL)
   {
      printf("Failed to load lazy font! SDL_ttf Error: %s\n", TTF_GetError());
      success = false;
   }
   else
   {
      //Set text color as black
      SDL_Color textColor = { 255, 255, 255, 255 };

      //Load prompt texture
      if (!gPromptTextTexture.loadFromRenderedText("Press Enter to Reset Start Time.", textColor))
      {
         printf("Unable to render prompt texture!\n");
         success = false;
      }
   }

   return success;
}

void MainLoop()
{
   Ball FirstBall{50, 50, 3, gRenderer};
   FirstBall.SetSpeeds(0.02f, 0.f);



   if (!loadMedia())
   {
      std::cout << "Failed to load media.\n";
   }
   else
   {
      // For calculating frames:
      SDL_Color textColor = { 255, 255, 255, 255 }; // white

      // Current time start time
      Uint32 startTime = 0;

      //The frames per second timer
      LTimer fpsTimer;

      //In memory text stream
      std::stringstream timeText;

      //Start counting frames per second
      int countedFrames = 0;
      fpsTimer.start();


      // While application is running -> infinite loop
      while (!gQuit)
      {
         // (1) Handle input
         //Input();
            // Check for quit event to close the window
         SDL_Event e;

         // Constantly pull and see if there are any events here
         while (SDL_PollEvent(&e) != 0)
         {
            if (e.type == SDL_QUIT) {
               gQuit = true;
            }
            // Reset start time on return keypress
            else if (e.type == SDL_KEYDOWN && e.key.keysym.sym == SDLK_RETURN)
            {
               // SDL_GetTicks() returns the time since the program started in milliseconds.
               startTime = SDL_GetTicks();
            }
         }



         // (2) Handle Updates

         // Change the Ball obj x parameter every frame
         FirstBall.m_CenterX += FirstBall.m_SpeedX * ((SDL_GetTicks() - startTime)/100);
         std::cout << FirstBall.m_CenterX << "\n";
         

         if (FirstBall.m_CenterX > gSCREEN_WIDTH)
         {
            FirstBall.m_CenterX = gSCREEN_WIDTH;
            FirstBall.m_SpeedX *= -1.1f;
         }

         if (FirstBall.m_CenterX < 0.f)
         {
            FirstBall.m_CenterX = 0.f;
            FirstBall.m_SpeedX *= -1.1f;
         }


         // Following LazyFoo SDL tutorial 22_Timing @https://lazyfoo.net/tutorials/SDL/22_timing/index.php
         
         // Set text to be rendered
         //timeText.str("");
         //timeText << "Milliseconds since start time " << SDL_GetTicks() - startTime;

         //// Render text
         //if (!gTimeTextTexture.loadFromRenderedText(timeText.str().c_str(), textColor))
         //{
         //   printf("Unable to render time texture!\n");
         //}

         //Calculate and correct fps
         float avgFPS = countedFrames / (fpsTimer.getTicks() / 1000.f);
         if (avgFPS > 2000000)
         {
            avgFPS = 0;
         }
         std::cout << avgFPS << "\n";

         //Set text to be rendered
         timeText.str("");
         timeText << "Average Frames Per Second " << avgFPS;

         //Render text
         if (!gFPSTextTexture.loadFromRenderedText(timeText.str().c_str(), textColor))
         {
            printf("Unable to render FPS texture!\n");
         }

         // (3) Clear and Draw the screen

         // Since SDL_RenderClear gives us a white screen once it clears, we should set the color first so it leaves in the Renderer state.
         SDL_SetRenderDrawColor(gRenderer, 0, 0, 0, SDL_ALPHA_OPAQUE);
         // Gives us a clear "canvas"
         SDL_RenderClear(gRenderer);

         //Render textures
         gPromptTextTexture.render((gSCREEN_WIDTH - gPromptTextTexture.getWidth()) / 2, 0);
         gTimeTextTexture.render((gSCREEN_WIDTH - gPromptTextTexture.getWidth()) / 2, (gSCREEN_HEIGHT - gPromptTextTexture.getHeight()) / 2);

         //Render textures
         gFPSTextTexture.render((gSCREEN_WIDTH - gFPSTextTexture.getWidth()) / 2, (gSCREEN_HEIGHT - gFPSTextTexture.getHeight()) / 2);

         // Do our drawing
         // But first, change the state of what we're drawing, i.e, we use the renderer which holds these states
         SDL_SetRenderDrawColor(gRenderer, 255, 255, 255, SDL_ALPHA_OPAQUE);
         FirstBall.Draw();

         // Finally show what we've drawn
         SDL_RenderPresent(gRenderer);
      }
   }

   
}

void CleanUp()
{
   //Free loaded images
   gTimeTextTexture.free();
   gPromptTextTexture.free();

   //Free global font
   TTF_CloseFont(gFont);
   gFont = NULL;

  // Destroy window
   SDL_DestroyRenderer(gRenderer);
   SDL_DestroyWindow(gWindow);
   gWindow = NULL;
   gRenderer = NULL;

   //Quit SDL subsystems
   TTF_Quit();
   IMG_Quit();
   SDL_Quit();
}


int main(int argc, char* argv[])
{

   InitializeSDLWindow();

   // Create rectangles (paddles)
   // Create the ball


   MainLoop();

   CleanUp();

   return 0;
}

